![Logseq Graph](./images/logseq_моя%20инфраструктура.png)


**Как все в итоге реализовано**:

Здесь находятся файлы для автоматического развертывания системы при коммите. Приближенная схема реализации **GitOps**.
**Vagrantfile** - файл для развертывания трех ВМ с активацией скрипта **python.sh**
**python.sh** - скрипт по установке python на каждую ВМ.

**Python** на каждой ВМ нужен для работы **Ansible**.

**Ansible** устанавливает **helm** и **ArgoCD** на соответствующие ВМ.

Сам ansible playbook и inventory file для ansible лежит в репозитории [git@github.com:soldatviktimnosti/ansible.git](https://github.com/soldatviktimnosti/ansible.git)

Также в этом репозитории есть два скрипта:

**git-monitor.sh** и **deploy-infra.sh**
**git-monitor.sh** - запускается у меня на хосте и смотрит есть ли новые коммиты в этом репозитории.
Если есть - **git-monitor.sh** выполняет команду,активирующую **deploy-infra.sh**

**deploy-infra.sh** принимает две ссылки на два git repo: этот и там где ansible playbook.

**deploy-infra.sh** уничтожает старые ВМ (потому что изменения в коммите могут быть связаны и с Vagrantfile), ставит новые ВМ исходя из содержимого Vagrantfile в репозитории.

Также, после уничтожения ВМ удаляются все метаданные ВМ, чтобы не было конфликтов имен. После развертывания новых ВМ метаданные сохраняются в отдельный файл на хосте, который надо будет применить командой:

```
source ~/.vagrant_env
```
Теперь можно будет подключаться к ВМ без указания их директории - а директории при каждой итерации скрипта новые, и это неудобно.

Далее, **deploy-infra.sh** активирует репозиторий с ansible, где лежит ansible playbook и устанавливает ArgoCD и helm на соответствующие ВМ.

**Вот так при каждом изменении у меня разворачивается система**
Единственное - **git-monitor.sh** должен быть всегда запущен у меня на хосте
